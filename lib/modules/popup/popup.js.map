{"version":3,"sources":["../../../src/components/modules/popup/popup.jsx"],"names":[],"mappings":"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","file":"popup.js","sourcesContent":["import React from 'react';\nimport ReactDOM from 'react-dom';\nimport Transition from 'react-motion-ui-pack';\nimport Portal from 'react-portal';\nimport EventListener from 'react-event-listener';\nimport throttle from 'lodash.throttle';\nimport shallowCompare from 'react-addons-shallow-compare';\nimport PopupElement, { POSITIONS } from './popupelement';\nimport { isNodeInRoot } from '../../utilities';\n\n/**\n * Popup with animations\n */\nexport default class Popup extends React.Component {\n    static propTypes = {\n        ...PopupElement.propTypes,\n        /**\n         * True to display the popup. If false will be hidden\n         */\n        active: React.PropTypes.bool,\n        /**\n         * Auto position popup when needed\n         */\n        autoPosition: React.PropTypes.bool,\n        /**\n         * Offset for distance of popup from element\n         */\n        distanceAway: React.PropTypes.number,\n        /**\n         * End animation\n         */\n        endAnimation: React.PropTypes.object,\n        /**\n         * Use this position when element fails to fit on screen in all tried positions\n         * If omitted, the last tried position will be used instead\n         */\n        lastResortPosition: React.PropTypes.string,\n        /**\n         * Offset in pixels from calculated position\n         */\n        offset: React.PropTypes.number,\n        /**\n         * Callback when popup wants to be closed (i.e. when offscreen or clicked outside)\n         */\n        onRequestClose: React.PropTypes.func,\n        /**\n         * When auto-positioning popup use opposite direction or adjacent as next position\n         */\n        prefer: React.PropTypes.oneOf(['adjacent', 'opposite']),\n        /**\n         * If true will prevent clicking on the other elements\n         */\n        preventElementClicks: React.PropTypes.bool,\n        /**\n         * Hide popup when target element scrolls off the screen\n         */\n        requestCloseWhenOffScreen: React.PropTypes.bool,\n        /**\n         * Start animation\n         */\n        startAnimation: React.PropTypes.object,\n        /**\n         * Target element to apply popup\n         */\n        target: React.PropTypes.object\n    };\n\n    static defaultProps = {\n        ...PopupElement.defaultProps,\n        requestCloseWhenOffScreen: true,\n        autoPosition: true,\n        active: false,\n        distanceAway: 0,\n        offset: 0,\n        startAnimation: {\n            scale: 1\n        },\n        endAnimation: {\n            scale: 0\n        },\n        onRequestClose: () => {},\n        preventElementClicks: true,\n        prefer: 'adjacent'\n    };\n\n    constructor(props) {\n        super(props);\n\n        // Handle resize / scrolls handler\n        this.handleResize = throttle(this.setPlacement.bind(this), 100);\n        this.handleScroll = throttle(this.setPlacement.bind(this, true), 100);\n\n        /**\n         * Array of current tried positions\n         * @type {Array}\n         */\n        this.positionsTried = [];\n        \n        this.state = {\n            active: this.props.active,\n            closing: false,\n            // Need to save position to state, since it could be changed by autoPosition\n            position: props.position, // eslint-disable-line\n            positionStyleTop: '0px',\n            positionStyleLeft: '0px'\n        };\n    }\n    \n    componentDidMount() {\n        if (this.props.active) {\n            // Set initial position for popup\n            this.setPlacement();\n        }\n    }\n\n\n    componentWillReceiveProps(nextProps) {\n        if (nextProps.active !== this.state.active) {\n            if (nextProps.active) {\n                // Display popup, set active state\n                this.setState({\n                    active: true,\n                    position: nextProps.position\n                });\n            } else {\n                // need to wait to play animation and keep portal active\n                this.positionsTried = [];\n                this.setState({\n                    closing: true\n                });\n                setTimeout(() => {\n                    // Hide popup\n                    this.setState({\n                        active: false,\n                        closing: false\n                    });\n                }, 500);\n            }\n        }\n    }\n    \n    shouldComponentUpdate(nextProps, nextState) {\n        // since we're changing state immediately after componentDidUpdate we need to prevent re-rendering loop\n        return shallowCompare(this, nextProps, nextState);\n    }\n\n    componentDidUpdate() {\n        // Set popup position after update\n        this.setPlacement();\n    }\n    \n    onOutsideClick(event) {\n        if (!this.state.active || this.state.closing) {\n            return;\n        }\n        if (!this.refs.popup || !this.refs.popup.refs.popup) {\n            return;\n        }\n        if (isNodeInRoot(event.target, this.refs.popup.refs.popup)) {\n            return;\n        }\n        event.stopPropagation();\n        this.props.onRequestClose(event);\n    }\n\n    render() {\n        // consuming position from props here since it's passing it from state\n        /* eslint-disable no-use-before-define, react/prop-types */\n        let { active, autoPosition, distanceAway, lastResortPosition, offset, startAnimation, endAnimation,\n            onRequestClose, prefer, position, preventElementClicks, requestCloseWhenOffScreen, target, style, ...other } = this.props;\n        /* eslint-enable no-use-before-define, react/prop-types */\n        \n        // Apply invisible layer to portal if preventElementClicks is true\n        const portalStyle = {\n            position: 'fixed',\n            top: 0,\n            bottom: 0,\n            left: 0,\n            right: 0\n        };\n        \n        // Create style for popup\n        const positionStyle = {\n            left: this.state.positionStyleLeft,\n            top: this.state.positionStyleTop,\n            bottom: 'auto',\n            right: 'auto',\n            display: 'block',\n            position: 'fixed' // need it to be fixed to avoid it with bloating code with many checks\n        };\n        \n        const popupStyle = style ? { ...style, ...positionStyle } : positionStyle;\n        \n        return (\n            <Portal isOpened={this.state.active || (!this.state.active && this.state.closing)}\n                    style={this.props.preventElementClicks ? portalStyle : {}}\n            >\n                <noscript>\n                    <EventListener elementName=\"document\"\n                                   onMouseDown={this.onOutsideClick.bind(this)}\n                                   onTouchStart={this.onOutsideClick.bind(this)}/>\n                    <EventListener elementName=\"window\"\n                                   onResize={this.handleResize}\n                                   onScroll={this.handleScroll}/>\n                    <Transition\n                        component={false}\n                        enter={startAnimation}\n                        leave={endAnimation}\n                    >\n                        {(this.state.active && !this.state.closing) &&\n                        <PopupElement\n                            {...other}\n                            key=\"popup\"\n                            position={this.state.position}\n                            ref=\"popup\"\n                            style={popupStyle}/>\n                        }\n                    </Transition>\n                </noscript>\n            </Portal>\n        );\n    }\n\n    /**\n     * Return target element boundaries\n     * @param element {HTMLElement}\n     */\n    getTargetPosition(element) {\n        const rect = element.getBoundingClientRect();\n        let left = rect.left;\n        let top = rect.top;\n\n        return {\n            top: top,\n            left: left,\n            right: left + element.offsetWidth,\n            bottom: top + element.offsetHeight,\n            width: element.offsetWidth,\n            height: element.offsetHeight,\n            center: left + element.offsetWidth / 2,\n            middle: top + element.offsetHeight / 2\n        };\n    }\n\n    /**\n     * Return popup element boundaries\n     * @param element {HTMLElement}\n     */\n    getPopupDimensions(element) {\n        return {\n            width: element.offsetWidth,\n            height: element.offsetHeight,\n            center: element.offsetWidth / 2,\n            middle: element.offsetHeight / 2\n        }\n    }\n\n    /**\n     * Set popup position\n     */\n    setPlacement(scrolling = false) {\n        if (!this.state.active || this.state.closing) {\n            return;\n        }\n        if (!this.refs.popup || !this.refs.popup.refs || !this.refs.popup.refs.popup) {\n            return;\n        }\n        let popupHTMLElement = this.refs.popup.refs.popup;\n\n        // If target wasn't provided, then assuming that popup used as child of element, we can obtain target then\n        let targetEl = this.props.target || ReactDOM.findDOMNode(this);\n        if (!targetEl) {\n            return;\n        }\n        \n        // mark current position as tried\n        this.positionsTried.push(this.state.position);\n\n        const targetElementPosition = this.getTargetPosition(targetEl);\n        const popupDimensions = this.getPopupDimensions(popupHTMLElement);\n        \n        if (scrolling && this.props.requestCloseWhenOffScreen) {\n            this.requestCloseWhenOffScreen(targetElementPosition);\n        }\n        \n        // need to know margins\n        const computedStyle = window.getComputedStyle(popupHTMLElement);\n        const margins = {\n            top: parseFloat(computedStyle.marginTop),\n            bottom: parseFloat(computedStyle.marginBottom),\n            left: parseFloat(computedStyle.marginLeft),\n            right: parseFloat(computedStyle.marginRight)\n        };\n        // assuming that all margins should be equal, using it because if popup will be autopositioned to opposite direction, then\n        // getComputedStyle will not return correct margin, since it could be not-rerendered yet\n        let margin = margins.bottom || margins.right || margins.left || margins.top || 0;\n        // calculate popup position\n        let finalPosition = this.calculatePopupPosition(this.state.position, targetElementPosition, popupDimensions, margin);\n        // Recalculate position if needed\n        let nextPosition = null;\n        if (this.props.autoPosition && this.positionsTried.length <= POSITIONS.length) {\n            nextPosition = this.autoPosition(finalPosition, popupDimensions);\n            if (nextPosition) {\n                finalPosition = this.calculatePopupPosition(nextPosition, targetElementPosition, popupDimensions, margin);\n            }\n        }\n        \n        this.setState({\n            position: nextPosition ? nextPosition : this.state.position, // eslint-disable-line\n            positionStyleTop: `${finalPosition.top}px`,\n            positionStyleLeft: `${finalPosition.left}px`\n        });\n        \n        // apply position to popup\n/*        popupHTMLElement.style.left = `${finalPosition.left}px`;\n        popupHTMLElement.style.top = `${finalPosition.top}px`;\n        popupHTMLElement.style.bottom = 'auto';\n        popupHTMLElement.style.right = 'auto';\n        popupHTMLElement.style.display = 'block';*/\n        \n        \n    }\n\n    /**\n     * Attempt to auto-position popup\n     */\n    autoPosition(finalPosition, popupDimensions) {\n        if (finalPosition.top < 0 || finalPosition.top + popupDimensions.height > window.innerHeight \n            || finalPosition.left < 0 || finalPosition.left + popupDimensions.width > window.innerWidth) {\n            // obtain next position\n            let nextPosition = this.getNextPosition();\n            // if every position tried set to lastResortPosition if given\n            if (!nextPosition) {\n                // in case of prefer=opposite fill positionsTried array manually\n                this.positionsTried = [...POSITIONS];\n                if (this.props.lastResortPosition) {\n                    nextPosition = this.props.lastResortPosition;\n                } else {\n                    nextPosition = this.state.position;\n                }\n            }\n            return nextPosition;\n        } else {\n            // looks like we found a good position reset lastPositions list\n            this.positionsTried = [];\n        }\n        return null;\n    }\n\n    /**\n     * Return next popup position to try depending of current prefer style, or null if every position was tried\n     */\n    getNextPosition() {\n        if (this.positionsTried.length >= POSITIONS.length) {\n            return null;\n        }\n        let currentPositionIndex = POSITIONS.indexOf(this.state.position);\n        if (currentPositionIndex === -1) {\n            return null;\n        }\n\n        switch (this.props.prefer) {\n        case 'adjacent':\n        default:\n            let nextPosition = null;\n            // We know now that at least one untried position should be available here\n            /* eslint-disable no-constant-condition */\n            while (true) {\n                // Reset index if we're off from array\n                if (currentPositionIndex + 1 > POSITIONS.length) {\n                    currentPositionIndex = 0;\n                }\n                nextPosition = POSITIONS[currentPositionIndex];\n                if (this.positionsTried.indexOf(nextPosition) === -1) {\n                    break;\n                }\n                currentPositionIndex++;\n            }\n            /* eslint-enable no-constant-condition */\n            return nextPosition;\n        case 'opposite':\n            // just return opposite direction\n            switch (this.state.position) {\n            case 'left center':\n                return (this.positionsTried.indexOf('right center') === -1) ? 'right center' : null;\n            case 'right center':\n                return (this.positionsTried.indexOf('left center') === -1) ? 'left center' : null;\n            case 'top left':\n                return (this.positionsTried.indexOf('bottom left') === -1) ? 'bottom left' : null;\n            case 'top center':\n                return (this.positionsTried.indexOf('bottom center') === -1) ? 'bottom center' : null;\n            case 'top right':\n                return (this.positionsTried.indexOf('bottom right') === -1) ? 'bottom right' : null;\n            case 'bottom left':\n                return (this.positionsTried.indexOf('top left') === -1) ? 'top left' : null;\n            case 'bottom center':\n                return (this.positionsTried.indexOf('top center') === -1) ? 'top center' : null;\n            case 'bottom right':\n                return (this.positionsTried.indexOf('top right') === -1) ? 'top right' : null;\n            default:\n                return null;\n            }\n        }\n    }\n\n    /**\n     * Return true if element is off screen\n     * @param targetPosition\n     */\n    requestCloseWhenOffScreen(targetPosition) {\n        if (targetPosition.top < 0 || targetPosition.top > window.innerHeight\n        || targetPosition.left < 0 || targetPosition.left > window.innerWidth) {\n            this.props.onRequestClose();\n        }\n    }\n    \n    \n    /**\n     * Return popup position by taking account of elements boundaries and current this.state.position\n     * @param position\n     * @param targetPosition\n     * @param popupDimensions\n     * @param margin {number}\n     */\n    calculatePopupPosition(position, targetPosition, popupDimensions, margin) {\n        let offset = this.props.offset;\n        let distanceAway = this.props.distanceAway;\n\n        switch (position) {\n        case 'top left':\n            return {\n                left: targetPosition.left + offset,\n                top: targetPosition.top - popupDimensions.height - margin - distanceAway\n            };\n        case 'top center':\n            return {\n                left: targetPosition.center - popupDimensions.center + offset,\n                top: targetPosition.top - popupDimensions.height - margin - distanceAway\n            };\n        case 'top right':\n            return {\n                left: targetPosition.right - popupDimensions.width - offset,\n                top: targetPosition.top - popupDimensions.height - margin - distanceAway\n            };\n        case 'left center':\n            return {\n                left: targetPosition.left - popupDimensions.width - margin - distanceAway,\n                top: targetPosition.middle - popupDimensions.middle + offset\n            };\n        case 'right center':\n            // not needed here to take margins into account\n            return {\n                left: targetPosition.right + distanceAway,\n                top: targetPosition.middle - popupDimensions.middle + offset\n            };\n        case 'bottom left':\n            return {\n                left: targetPosition.left + offset,\n                top: targetPosition.bottom + distanceAway\n            };\n        case 'bottom center':\n            return {\n                left: targetPosition.center - popupDimensions.center + offset,\n                top: targetPosition.bottom + distanceAway\n            };\n        case 'bottom right':\n            return {\n                left: targetPosition.right - popupDimensions.width - offset,\n                top: targetPosition.bottom + distanceAway\n            };\n        }\n    }\n\n}\n"]}